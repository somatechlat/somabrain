#!/usr/bin/env bash
set -euo pipefail
# dev_up.sh - single canonical helper to start the dev stack
# Behavior:
# - Detect free host ports for key services (if default port in use, pick next free)
# - Write .env.local with chosen host port mappings
# - Start docker compose with Docker_Canonical.yml using .env.local
# - Wait for somabrain health endpoint and write ports.json for testers

ROOT=$(cd "$(dirname "$0")/.." && pwd)
cd "$ROOT"

# Default memory endpoint (use host.docker.internal for macOS, fall back to localhost)
MEMORY_ENDPOINT=${SOMABRAIN_MEMORY_HTTP_ENDPOINT:-http://host.docker.internal:9595}
MEMORY_BASE=${MEMORY_ENDPOINT%:*}
if [[ "$MEMORY_BASE" == "http" || "$MEMORY_BASE" == "$MEMORY_ENDPOINT" ]]; then
    MEMORY_BASE=$MEMORY_ENDPOINT
fi

ENVFILE=.env.local
echo "# Generated by scripts/dev_up.sh" > $ENVFILE

# Function to find next available port starting from a given port
find_free_port() {
    local start_port=$1
    local port=$start_port
    while lsof -i :$port >/dev/null 2>&1; do
        ((port++))
        if [ $port -gt 65535 ]; then
            echo "ERROR: No available ports found starting from $start_port" >&2
            return 1
        fi
    done
    echo $port
}

# Fixed port for SomaBrain app, auto-detect for infrastructure services
SOMABRAIN_PORT=9696
REDIS_PORT=$(find_free_port 6379)
KAFKA_PORT=$(find_free_port 9092)
PROMETHEUS_PORT=$(find_free_port 9090)
POSTGRES_PORT=$(find_free_port 15432)
MEMORY_PORT=$(find_free_port 9595)

echo "Port allocation:"
echo "  SomaBrain: $SOMABRAIN_PORT (fixed)"
echo "  Redis: $REDIS_PORT (auto-detected)"
echo "  Kafka: $KAFKA_PORT (auto-detected)"
echo "  Prometheus: $PROMETHEUS_PORT (auto-detected)"
echo "  Postgres: $POSTGRES_PORT (auto-detected)"
echo "  Memory: $MEMORY_PORT (auto-detected)"

# Write detected ports
cat <<PORTS >> $ENVFILE
SOMABRAIN_HOST_PORT=$SOMABRAIN_PORT
REDIS_HOST_PORT=$REDIS_PORT
KAFKA_HOST_PORT=$KAFKA_PORT
PROMETHEUS_HOST_PORT=$PROMETHEUS_PORT
POSTGRES_HOST_PORT=$POSTGRES_PORT
SOMAMEMORY_HOST_PORT=$MEMORY_PORT
PORTS

# Ensure the memory endpoint points to the dynamically detected port
echo "SOMABRAIN_MEMORY_HTTP_ENDPOINT=http://host.docker.internal:$MEMORY_PORT" >> $ENVFILE

# Production-like defaults for development: strict-real and full stack
cat <<'FLAGS' >> $ENVFILE
SOMABRAIN_FORCE_FULL_STACK=1
SOMABRAIN_STRICT_REAL=1
SOMABRAIN_REQUIRE_MEMORY=1
SOMABRAIN_MODE=enterprise
SOMABRAIN_PREDICTOR_PROVIDER=mahal
FLAGS

echo "Wrote $ENVFILE:" && sed -n '1,200p' $ENVFILE

echo "Cleaning any previous compose state (down --remove-orphans)"
docker compose --env-file $ENVFILE -f Docker_Canonical.yml down --remove-orphans || true
echo "Bringing up docker compose (this will build the somabrain image)..."
docker compose --env-file $ENVFILE -f Docker_Canonical.yml up -d --build somabrain redis kafka prometheus postgres

# Wait for somabrain health
SOMABRAIN_PORT=$(grep '^SOMABRAIN_HOST_PORT=' $ENVFILE | cut -d= -f2)
echo "Waiting for somabrain on http://localhost:${SOMABRAIN_PORT}/health"
for i in $(seq 1 60); do
  if curl -fsS "http://localhost:${SOMABRAIN_PORT}/health" >/dev/null 2>&1; then
    echo "somabrain healthy"
    break
  fi
  sleep 2
done

echo "Writing ports.json"
python3 - <<PY
import json,subprocess
env={}
with open('.env.local') as f:
    for l in f:
        if '=' in l:
            k,v=l.strip().split('=',1)
            env[k]=v
ports={}
ports.update(env)
services=['somabrain','redis','kafka','prometheus','postgres']
port_map={'somabrain':'9696','redis':'6379','kafka':'9092','prometheus':'9090','postgres':'5432'}
for s in services:
    try:
        # Map each service to its container port for port lookup
        container_port = port_map[s]
        out=subprocess.check_output(['docker','compose','-f','Docker_Canonical.yml','port',s,container_port], text=True).strip()
        ports[s+'_host_mapping']=out
    except Exception:
        ports[s+'_host_mapping']=''
open('ports.json','w').write(json.dumps(ports,indent=2))
print('wrote ports.json')
PY

echo "Done. Use ports.json for test harness or inspect with 'cat ports.json'"
