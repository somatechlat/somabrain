<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>SomaBrain Monitoring Dashboard</title>
  <!-- D3.js CDN -->
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body {font-family: Arial, sans-serif; margin: 20px; background: #f9f9f9;}
    h1 {color: #333;}
    #controls {margin-bottom: 20px;}
    .chart {margin-top: 30px;}
    .bar {fill: steelblue;}
    .axis text {font-size: 12px;}
    .axis path, .axis line {stroke: #ccc;}
    /* Tooltip styling */
    .d3-tooltip {
      position: absolute;
      padding: 6px;
      background: rgba(0,0,0,0.7);
      color: #fff;
      border-radius: 4px;
      pointer-events: none;
      opacity: 0;
    }
    /* Responsive grid for charts */
    #charts {display: flex; flex-wrap: wrap; gap: 20px; justify-content: center;}
    .chart {flex: 1 1 400px; max-width: 600px;}
    /* Enhance button styling */
    #refreshBtn {background:#1f77b4;color:#fff;padding:6px 12px;border:none;border-radius:4px;cursor:pointer;}
    #refreshBtn:hover {background:#155a8a;}
  </style>
</head>
<body>
  <h1>SomaBrain Monitoring (D3.js)</h1>
  <div id="controls">
    <label for="targetSelect">Server:</label>
    <select id="targetSelect">
  <option value="9696">Dev (9696)</option>
  <option value="9696">Prod (9696)</option>
    </select>
    <button id="refreshBtn">Refresh</button>
  </div>
  <div id="charts">
    <div id="requestRate" class="chart"></div>
    <div id="wmUtil" class="chart"></div>
    <div id="latency" class="chart"></div>
    <!-- New containers for gauge and line chart -->
    <div id="wmGauge" class="chart"></div>
    <div id="requestLine" class="chart"></div>
    <!-- New container for latency histogram -->
    <div id="latencyHist" class="chart"></div>
  </div>

  <script>
  // Helper to fetch raw Prometheus exposition format from the SomaBrain instance
  async function fetchMetrics(port) {
    // Use the local proxy (serve_monitor) which adds CORS headers and forwards to the target SomaBrain port.
    const resp = await fetch(`http://127.0.0.1:8083/metrics?port=${port}`);
    const text = await resp.text();
    return text;
  }

  // Parse a metric line like: somabrain_http_requests_total{job="somabrain_dev"} 12345
  function parseMetric(text, metricName) {
    const lines = text.split('\n');
    const result = {};
    const regex = new RegExp(`^${metricName}{([^}]*)}\\s+(\\d+(?:\\.\\d+)?)`);
    for (const line of lines) {
      const m = line.match(regex);
      if (m) {
        const labels = m[1];
        const value = +m[2];
        result[labels] = value;
      }
    }
    return result;
  }

  // Parse histogram buckets for latency
  function parseHistogram(text, baseName) {
    const lines = text.split('\n');
    const buckets = [];
    const regex = new RegExp(`^${baseName}_bucket{([^}]*)}\\s+(\\d+(?:\\.\\d+)?)`);
    for (const line of lines) {
      const m = line.match(regex);
      if (m) {
        const labelPart = m[1];
        const count = +m[2];
        const leMatch = labelPart.match(/le="([^\"]+)"/);
        if (leMatch) {
          const le = parseFloat(leMatch[1]);
          buckets.push({ le, count });
        }
      }
    }
    buckets.sort((a, b) => a.le - b.le);
    const total = buckets.length ? buckets[buckets.length - 1].count : 0;
    return buckets.map(b => ({ le: b.le, value: total ? (b.count / total) * 100 : 0 }));
  }

  // Tooltip div (single instance reused)
  const tooltip = d3.select('body').append('div')
    .attr('class', 'd3-tooltip')
    .style('position', 'absolute')
    .style('padding', '6px')
    .style('background', 'rgba(0,0,0,0.7)')
    .style('color', '#fff')
    .style('border-radius', '4px')
    .style('pointer-events', 'none')
    .style('opacity', 0);

  // Render bar chart with tooltip
  function renderBarChart(containerId, dataMap, title) {
    const data = Object.entries(dataMap).map(([k, v]) => ({ label: k, value: v }));
    const width = 600, height = 300, margin = { top: 30, right: 20, bottom: 50, left: 60 };
    d3.select(containerId).selectAll('*').remove();
    const svg = d3.select(containerId).append('svg').attr('width', width).attr('height', height);
    const x = d3.scaleBand().domain(data.map(d => d.label)).range([margin.left, width - margin.right]).padding(0.1);
    const y = d3.scaleLinear().domain([0, d3.max(data, d => d.value) * 1.1]).nice().range([height - margin.bottom, margin.top]);
    svg.append('g').attr('fill', '#1f77b4')
      .selectAll('rect')
      .data(data)
      .join('rect')
      .attr('class', 'bar')
      .attr('x', d => x(d.label))
      .attr('y', d => y(d.value))
      .attr('height', d => y(0) - y(d.value))
      .attr('width', x.bandwidth())
      .on('mouseover', (event, d) => {
        tooltip.style('opacity', 1)
          .html(`<strong>${d.label}</strong>: ${d.value}`)
          .style('left', (event.pageX + 8) + 'px')
          .style('top', (event.pageY - 28) + 'px');
      })
      .on('mouseout', () => tooltip.style('opacity', 0));
    // Axes
    svg.append('g').attr('transform', `translate(0,${height - margin.bottom})`).call(d3.axisBottom(x)).selectAll('text').attr('transform', 'rotate(-45)').style('text-anchor', 'end');
    svg.append('g').attr('transform', `translate(${margin.left},0)`).call(d3.axisLeft(y));
    // Title
    svg.append('text').attr('x', width / 2).attr('y', margin.top / 2).attr('text-anchor', 'middle').attr('font-size', '16px').attr('fill', '#333').text(title);
  }

  // Render line chart for time series
  function renderLineChart(containerId, data, title) {
    const width = 600, height = 300, margin = { top: 30, right: 20, bottom: 50, left: 60 };
    d3.select(containerId).selectAll('*').remove();
    const svg = d3.select(containerId).append('svg').attr('width', width).attr('height', height);
    const x = d3.scaleTime().domain(d3.extent(timestamps)).range([margin.left, width - margin.right]);
    const y = d3.scaleLinear().domain([0, d3.max(data) * 1.1]).nice().range([height - margin.bottom, margin.top]);
    const line = d3.line().x((d, i) => x(timestamps[i])).y(d => y(d));
    svg.append('path').datum(data).attr('fill', 'none').attr('stroke', '#ff7f0e').attr('stroke-width', 2).attr('d', line);
    svg.append('g').attr('transform', `translate(0,${height - margin.bottom})`).call(d3.axisBottom(x).ticks(5));
    svg.append('g').attr('transform', `translate(${margin.left},0)`).call(d3.axisLeft(y));
    svg.append('text').attr('x', width / 2).attr('y', margin.top / 2).attr('text-anchor', 'middle').attr('font-size', '16px').attr('fill', '#333').text(title);
  }

  // Render gauge for WM utilization (0‑1 range)
  function renderWmGauge(containerId, value) {
    const width = 200, height = 200, radius = Math.min(width, height) / 2;
    d3.select(containerId).selectAll('*').remove();
    const svg = d3.select(containerId).append('svg').attr('width', width).attr('height', height);
    const arc = d3.arc()
      .innerRadius(radius * 0.7)
      .outerRadius(radius * 0.9)
      .startAngle(-Math.PI / 2)
      .endAngle(d => -Math.PI / 2 + d * Math.PI);
    const g = svg.append('g').attr('transform', `translate(${width / 2},${height / 2})`);
    // background
    g.append('path').datum(1).attr('fill', '#e6e6e6').attr('d', arc);
    // value
    g.append('path').datum(value).attr('fill', '#1f77b4').attr('d', arc);
    // label
    g.append('text').attr('text-anchor', 'middle').attr('dy', '0.35em').attr('font-size', '24px').text((value * 100).toFixed(1) + '%');
    svg.append('text').attr('x', width / 2).attr('y', margin.top).attr('text-anchor', 'middle').attr('font-size', '14px').attr('fill', '#333').text('WM Utilization');
  }

  // Render latency histogram (percentage per bucket)
  function renderHistogram(containerId, data, title) {
    const width = 600, height = 300, margin = { top: 30, right: 20, bottom: 50, left: 60 };
    d3.select(containerId).selectAll('*').remove();
    const svg = d3.select(containerId).append('svg').attr('width', width).attr('height', height);
    const x = d3.scaleBand().domain(data.map(d => d.le)).range([margin.left, width - margin.right]).padding(0.1);
    const y = d3.scaleLinear().domain([0, d3.max(data, d => d.value) * 1.1]).nice().range([height - margin.bottom, margin.top]);
    svg.append('g').selectAll('rect').data(data).enter().append('rect')
      .attr('x', d => x(d.le))
      .attr('y', d => y(d.value))
      .attr('height', d => y(0) - y(d.value))
      .attr('width', x.bandwidth())
      .attr('fill', '#ff7f0e');
    svg.append('g').attr('transform', `translate(0,${height - margin.bottom})`).call(d3.axisBottom(x).tickFormat(d => d.toString()))
      .selectAll('text').attr('transform', 'rotate(-45)').style('text-anchor', 'end');
    svg.append('g').attr('transform', `translate(${margin.left},0)`).call(d3.axisLeft(y));
    svg.append('text').attr('x', width / 2).attr('y', margin.top / 2).attr('text-anchor', 'middle').attr('font-size', '16px').attr('fill', '#333').text(title);
  }

  // History buffers for time‑series charts
  const maxPoints = 30;
  const requestHistory = [];
  const wmHistory = [];
  const timestamps = [];
  function addHistory(req, wm) {
    const now = new Date();
    if (requestHistory.length >= maxPoints) { requestHistory.shift(); wmHistory.shift(); timestamps.shift(); }
    requestHistory.push(req);
    wmHistory.push(wm);
    timestamps.push(now);
  }

  // Main refresh routine – gathers metrics and updates every chart gracefully handling missing data.
  async function enhancedRefresh() {
    const port = document.getElementById('targetSelect').value;
    const raw = await fetchMetrics(port);
    // Parse metrics (fallback to empty object if not present)
    const requestData = parseMetric(raw, 'somabrain_http_requests_total');
    const wmData = parseMetric(raw, 'somabrain_wm_utilization');
    const latencyRaw = parseMetric(raw, 'somabrain_http_latency_seconds');
    const requestVal = Object.values(requestData)[0] || 0;
    const wmVal = Object.values(wmData)[0] || 0;
    const latencyData = {};
    for (const [k, v] of Object.entries(latencyRaw)) { latencyData[k] = v * 1000; }
    // Update charts
    renderBarChart('#requestRate', requestData, 'HTTP Requests Total');
    renderBarChart('#wmUtil', wmData, 'Working Memory Utilization');
    renderBarChart('#latency', latencyData, 'Avg HTTP Latency (ms)');
    // Time‑series
    addHistory(requestVal, wmVal);
    renderLineChart('#requestLine', requestHistory, 'Requests Over Time');
    renderWmGauge('#wmGauge', wmVal);
    // Histogram for latency distribution
    const histData = parseHistogram(raw, 'somabrain_http_latency_seconds');
    renderHistogram('#latencyHist', histData, 'Latency Distribution (%)');
  }

  // Bind UI controls
  document.getElementById('refreshBtn').addEventListener('click', enhancedRefresh);
  // Auto‑refresh every 30 seconds
  setInterval(enhancedRefresh, 30000);
  // Initial load
  enhancedRefresh();
  </script>
</body>
</html>
