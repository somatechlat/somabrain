# Memory Operations

**Purpose** Describe how to write and retrieve memories through SomaBrain’s public API.

**Audience** Developers integrating the `/remember`, `/recall`, and related endpoints.

**Prerequisites** Running SomaBrain instance, memory backend reachable at `SOMABRAIN_MEMORY_HTTP_ENDPOINT`, and an authentication token (unless auth disabled for development).

---

## 1. Memory Payload Schema

`somabrain/schemas.py::MemoryPayload` defines the attributes accepted by `/remember`. Important fields:

| Field | Type | Notes |
|-------|------|-------|
| `task` | string | Short identifier for the memory (also used as the working‑memory key if no coordinate is supplied). |
| `content` | string | Free‑form text stored with the memory. |
| `importance` | float | Defaults to `1.0`. Higher values increase salience in working memory. |
| `memory_type` | string | Defaults to `"episodic"`. |
| `timestamp` | string/float | ISO‑8601 or UNIX seconds; normalised to epoch seconds. |
| `universe` | string | Optional logical namespace (overrides any `X-Universe` header). |
| `phase`, `quality_score`, `domains`, `reasoning_chain` | optional metadata used by planning flows. |
| `who`, `did`, `what`, `where`, `when`, `why` | Optional event tuple; auto-populated from `task` if omitted. |

Requests can wrap the payload (`{"payload": {...}}`) or send the fields at the top level for backwards compatibility.

---

## 2. Storing a Memory – `/remember`

```bash
curl -sS http://localhost:9696/remember \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer ${SOMABRAIN_API_TOKEN:-dev-token}" \
  -d '{
        "payload": {
          "task": "kb.geography.paris",
          "content": "Paris is the capital of France.",
          "memory_type": "episodic",
          "importance": 0.8,
          "timestamp": "2024-01-10T10:00:00Z"
        }
      }'
```

**Success response (`somabrain/schemas.py::RememberResponse`):**

```json
{
  "ok": true,
  "success": true,
  "namespace": "somabrain_ns:public",
  "trace_id": "140351384443504",
  "deadline_ms": null,
  "idempotency_key": null,
  "breaker_open": null,
  "queued": null
}
```

- `breaker_open=true` and `queued=true` mean the memory service was unavailable; the write was journaled and will be replayed when the backend recovers.
- `trace_id` echoes the request ID (either autogenerated or supplied as `X-Request-ID`).

**Failure scenarios**

| HTTP | Body | Cause | Remediation |
|------|------|-------|-------------|
| 400 | `{"detail": "Invalid payload: …"}` | Payload fails validation (missing required fields, malformed timestamp). | Fix request to match `MemoryPayload`. |
| 401/403 | `{"detail": "missing bearer token"}` | Auth required. | Provide valid token or disable auth for dev. |
| 429 | `{"detail": "rate limit exceeded"}` | Per-tenant write throttle triggered (`somabrain.ratelimit.RateLimiter`). | Slow down writes or adjust limits. |
| 503 | `{"detail": {"message": "memory backend unavailable; write queued", …}}` | `SOMABRAIN_REQUIRE_MEMORY=1` and the HTTP memory service failed. | Restore memory backend or relax the requirement. |

---

## 3. Recalling Memories – `/recall`

`somabrain/schemas.py::RecallResponse` surfaces three collections:

| Field | Description |
|-------|-------------|
| `wm` | Matches from working memory (`MultiTenantWM` or microcircuits). |
| `memory` | Long-term memory hits returned from the external memory service. |
| `results` | Legacy mirror of `memory` retained for client compatibility. |

Example query:

```bash
curl -sS http://localhost:9696/recall \
  -H "Content-Type: application/json" \
  -d '{
        "query": "capital of France",
        "top_k": 3
      }' | jq
```

Sample response (truncated):

```json
{
  "wm": [],
  "memory": [
    {
      "score": 0.86,
      "payload": {
        "task": "kb.geography.paris",
        "content": "Paris is the capital of France.",
        "memory_type": "episodic",
        "importance": 0.8
      },
      "_source": "ltm"
    }
  ],
  "results": [
    {
      "task": "kb.geography.paris",
      "content": "Paris is the capital of France.",
      "score": 0.86,
      "_source": "ltm"
    }
  ],
  "namespace": "somabrain_ns:public",
  "trace_id": "140351409864272"
}
```

The `score` is computed by `somabrain.scoring.UnifiedScorer` using weights drawn from the live adaptation state. If both `wm` and `memory` are empty, the memory backend did not return any matches (verify the write or adjust `top_k` / query text).

---

## 5. Controlling Namespaces and Universes

- Tenants are identified via `Authorization` + (optional) `X-Tenant-ID`. The default tenant is configured in `.env` (`SOMABRAIN_DEFAULT_TENANT`).
- Universes provide finer segmentation and can be supplied via the payload (`"universe": "support"`) or via `X-Universe`.
- Quotas are enforced per tenant (`somabrain.quotas.QuotaManager`). Exceeding quotas yields HTTP 429.

---

## 6. Cleanup & Deletion

SomaBrain exposes auxiliary endpoints when you need to tidy specific coordinates:

| Endpoint | Description |
|----------|-------------|
| `POST /delete` | Remove a memory by coord/key (requires payload with `coord` or `task`). |
| `POST /recall/delete` | Remove a memory surfaced by recall. |

Consult the [API Integration guide](api-integration.md) for request bodies and authentication requirements.

---

## 7. Monitoring Memory Operations

- Metrics: Prometheus exposes `somabrain_ltm_store_latency_seconds`, `somabrain_recall_latency_seconds`, and quota/rate-limit counters.
- Traces: Each response contains a `trace_id`. Supply `X-Request-ID` to correlate client calls with server logs.
- Journaling: When `persistent_journal_enabled` is `true` (see `somabrain.config.Config`), writes are appended to `journal_dir` for recovery if the memory backend is down.

Use these signals to verify that ingestion and recall behave as expected in your environment.
