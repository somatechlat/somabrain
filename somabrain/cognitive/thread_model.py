"""SQLAlchemy model for Cognitive Threads (Phase 5).

Each tenant can have a single active thread that stores a list of option IDs
generated by the Oak planner. The list is persisted as JSON and a cursor tracks
the next option to serve. The model is deliberately simple – it only stores the
tenant identifier, the JSON‑encoded options list, the integer cursor, and a
timestamp that is automatically updated on write.

The table is created by a migration (not included here) and is used by the
FastAPI router in ``somabrain.cognitive.thread_router``.
"""

from __future__ import annotations

import json
from datetime import datetime
from typing import Any, List, Optional

from sqlalchemy import Column, Integer, String, Text, DateTime, func

from somabrain.storage.db import Base
from common.config.settings import settings


class CognitiveThread(Base):
    """Persisted thread for a tenant.

    Columns
    -------
    tenant_id: str – primary key identifying the tenant.
    options_json: Text – JSON list of option identifiers (strings).
    cursor: int – index of the next option to return; ``0`` means start of list.
    updated_at: DateTime – last modification timestamp (auto‑managed).
    """

    __tablename__ = "cognitive_threads"

    tenant_id = Column(String(255), primary_key=True, nullable=False)
    options_json = Column(Text, nullable=True)
    cursor = Column(Integer, nullable=False, default=0)
    updated_at = Column(
        DateTime(timezone=True),
        server_default=func.now(),
        onupdate=func.now(),
        nullable=False,
    )

    def __init__(self, *args, **kwargs):  # noqa: D401
        """Initialize with a safe default cursor.

        SQLAlchemy column defaults are applied only after a flush, so when the
        model is instantiated directly (as in unit tests) ``self.cursor`` may be
        ``None``. Setting it to ``0`` ensures the ``next_option`` logic works
        without requiring a database round‑trip.
        """
        super().__init__(*args, **kwargs)
        if self.cursor is None:
            # Use centralized default cursor value from settings
            self.cursor = settings.COGNITIVE_THREAD_DEFAULT_CURSOR

    # Helper methods -----------------------------------------------------
    def get_options(self) -> List[str]:
        """Return the stored options as a list of strings.

        The column may be ``None`` – in that case an empty list is returned.
        """
        if not self.options_json:
            return []
        try:
            data = json.loads(self.options_json)
            if isinstance(data, list):
                return [str(item) for item in data]
        except Exception as exc: raise
        return []

    def set_options(self, options: List[Any]) -> None:
        """Store ``options`` as JSON.

        ``options`` may contain any JSON‑serialisable values; they are coerced to
        strings because the planner deals with option identifiers.
        """
        try:
            self.options_json = json.dumps([str(o) for o in options])
        except Exception as exc: raise
            self.options_json = None

    def next_option(self) -> Optional[str]:
        """Return the next option according to ``cursor`` and advance it.

        If the cursor is beyond the list length ``None`` is returned and the
        cursor is not modified.
        """
        opts = self.get_options()
        if self.cursor < 0 or self.cursor >= len(opts):
            return None
        opt = opts[self.cursor]
        # Advance cursor for next call
        self.cursor += 1
        return opt

    def reset(self) -> None:
        """Reset the thread – clear options and cursor."""
        self.options_json = None
        self.cursor = 0

    def __repr__(self) -> str:
        return (
            f"<CognitiveThread tenant_id={self.tenant_id} "
            f"options={len(self.get_options())} cursor={self.cursor}>"
        )
